#!/usr/bin/env ruby
#
# BioRuby bio-gfastqc Plugin BioGfastqc
# Author:: Raoul Jean Pierre Bonnal
# Copyright:: 2015
require 'json'
require 'base64'
require 'yaml'
require 'optparse'
require 'ostruct'
require 'zip'
require 'erb'
# Copyright 2015, Raoul Jean Pierre Bonnal <bonnal@ingm.org>
# This scripts reads and input file in YAML format followint
# the specification from pipengine for samples
# generates a single comprehesive html page with a summary for
# all the Quality Control data generated by FASTQC


USAGE = "Describe bio-gfastqc"

gempath = File.dirname(File.dirname(__FILE__))
$: << File.join(gempath,'lib')

VERSION_FILENAME=File.join(gempath,'VERSION')
version = File.new(VERSION_FILENAME).read.chomp

# print banner
print "bio-gfastqc #{version} by Raoul Jean Pierre Bonnal 2015\n"

if ARGV.size == 0
  print USAGE
end

require 'bio-gfastqc'

# Uncomment when using the bio-logger 
# require 'bio-logger'
# Bio::Log::CLI.logger('stderr')
# Bio::Log::CLI.trace('info')


class OptHandlingBox
  def  self.parse(args)
    options = OpenStruct.new
    options.config = 'config.yml'
    options.step = ''

    opt_parser =  OptionParser.new do |opts|
      opts.banner = 'Usage: qc_overview.rb '

      opts.on('-c', '--config [config]',
              'choose the config from get info about the samples') do |config|
        options.config = config
      end

      opts.on('-p', '--pipengine',
              'if you used pipengine to produce the fastqc result is better to use this option. gfastqc will look into the output directory specified in the sample.yml') do
        options.pipengine = true
      end


      opts.on('-s', '--step [STEP]',
              'choose the step from which extract the fastqc data') do |step|
        options.step = step
      end

      opts.on('-a', '--first [FIRST]',
              'forward strand reads') do |first|
        options.first = first
      end

      opts.on('-b', '--second [SECOND]',
              'reverse strand reads') do |second|
        options.second = second
      end


      opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
      end
    end #opt_parse

    opt_parser.parse!(args)
    options
  end #parse
end #class OptGtfSplit

options = OptHandlingBox.parse(ARGV)

if !File.exists?(options.config)
  puts
  puts "Warning: there is not config file #{options.config}"
  exit
end
config = YAML.load_file(options.config)
@data = {}
@tables = {}
@base_file_names = []
@base_file_names << options.first #this must be mandatory
@base_file_names << options.second if options.second # this can be optional

if options.pipengine 
  unless config['output']
    puts "Error: If you selected the compatible option -p/--pipengine, an 'output' tag must occour in your configuration file."
  end
end

config['samples'].each_pair do |name, path|
  @data[name] = {}
  @tables[name] = {}
  @base_file_names.each do |base_file_name|
    @data[name][base_file_name]={}
    @tables[name][base_file_name]={}
    file = File.join(options.pipengine ? File.join(config['output'], name) : path, options.step, "#{base_file_name}_fastqc.zip")
    Zip::File.open(file) do |zip_file|
      zip_file.glob('*/Images/*.png').each do |entry|
        field_name = File.basename(entry.name,".png")
        @data[name][base_file_name][field_name]=Base64.encode64(entry.get_input_stream.read)
      end #each entry
      zip_file.glob('*/fastqc_data.txt').each do |entry|
        entry.get_input_stream.read.scan(/>>(.*?)>>END_MODULE/m).each do |match|
          match_data = match.first.split("\n")
          field_name, status = match_data[0].split("\t")
          begin 
            header = match_data[1].tr("#","").split("\t")
            content = match_data[2..-1].map do |data_row|
              data_row.split("\t")
            end
            # puts field_name
            # puts header
            field_name = field_name.tr(" ","_")
            @tables[name][base_file_name][field_name]={ "status" => status,
              "header"=> header,
              "content" => content
            }
          rescue
            # $stderr.puts match_data.inspect #This is a generic warning to notify the user that this records has no data associated with.
          end

        end #match
      end #fastq data.txt
    end #zip
  end #files
end
# File.open('test.json','w') do |file|
#   file.write data.to_json
# end

@type_images = %w(kmer_profiles per_sequence_gc_content per_base_sequence_content duplication_levels sequence_length_distribution per_sequence_quality per_base_quality adapter_content per_base_n_content per_tile_quality)
@type_tables = %w(Adapter_Content Basic_Statistics Kmer_Content Per_base_N_content Per_base_sequence_content Per_base_sequence_quality Per_sequence_quality_scores Sequence_Duplication_Levels Sequence_Length_Distribution)
# dropped tables to avoid wast of space or not so informative:
# Per_sequence_GC_content Overrepresented_sequences Per_tile_sequence_quality 
# Overrepresented_sequences temporary removed it seems that when this fields pass the test there are no data associated with


erb_file = 'index.html.erb'

html_file = File.basename(erb_file, '.erb') #=>"page.html"

erb_str = File.read(File.join(File.dirname(__FILE__),'../lib/bio-gfastqc',erb_file))

renderer = ERB.new(erb_str)
result = renderer.result()

File.open(html_file, 'w') do |f|
  f.write(result)
end

puts "Your comprehensive quality control file is ready in the current directory #{File.join(Dir.pwd,'index.html')}"


